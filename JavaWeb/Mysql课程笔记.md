# 数据库设计规范
1. 所有数据库对象名称必须使用小写字母并用下划线分割
2. 所有数据库对象名称进制使用MySQL保留关键字  
`select id,username,from,age from tb_user`则改为(添加两个反向单引号)  
3. 数据库对象的命名要能见名识义，并且最好不超过32个字符（MySQL没有规定）
4. 临时库表必须以tmp为前缀并以日期为后缀  
备份库表必须以bak为前缀并以日期为后缀
5. 所有存储相同数据的列名和列类型必须一致  
![](http://p1.bpimg.com/567571/8634ae93174a976d.png)

# 数据库基本设计规范
1. Mysql5.5使用之前Myisam（默认存储引擎）情况：现在所有表必须使用Innodb存储引擎（5.6版本后的默认引擎）
2. 数据库和表分字符集统一使用UTF-8（MySQL中UTF-8字符集汉字占3字节，ASCII码占1字节）
3. 所有表和字段都需要添加注释（使用comment从句添加表和列的备注）
4. 尽量控制单表数据量的大小，建议控制在500万行以内（并不是MySQL的限制），可以使用历史数据归档、分库分表等手段控制数据量
5. 谨慎使用MySQL分区表（分区表在物理上表现为多个文件，在逻辑上表现为一个表），谨慎选择分区键，跨分区查询效率可能更低，建议采用物理分表的方式管理大数据
6. 尽量做到冷热数据分离，减小表的宽度（MySQL规定最多存储4096列），减少磁盘IO，更有效地利用缓存，经常一起使用的列放到一个表中
7. 禁止在表中建立预留字段（预留字段命名很难做到见名识义，并且无法确认存储的数据类型，对预留字段类型的修改会对表进行锁定）
8. 禁止在数据库中存储图片、文件等二进制数据，禁止在线上做数据库压力测试，禁止从开发环境测试环境直连生产环境数据库


# 索引设计规范
1. 限制每张表上的索引数量，建议单张表索引不超过5个（合适的索引数量可以提高效率，过多反而会降低效率），禁止给表中的每一列都建立单独的索引
2. 每个Innodb表必须有一个主键（若没有主键，会自动将第一列字段作为主键），且不使用更新频繁的列作为主键，不使用多列主键，不要使用UUID,MD5,HASH,字符串列作为主键，主键建议选择使用自增ID值
3. 常见索引列建议：SELECCT、UPDATE、DELETE语句的WHERE从句中的列，包含在ORDER BY、GROUP BY、DISTINCT中的字段，多表JOIN的关联列
4. 如何选择索引列的顺序：（为何使用索引？查询时通过索引进行数据查找，减少字段的随机IO，增强查询的性能）选择把区分度最高、字段长度小、使用最频繁的列放在联合索引的最左侧
5. 避免建立冗余索引如`index(a,b,c)、index(a,b)、index(a)`和重复索引如`primary key(id)、index(id)、unique index(id)`
6. 对于频繁的查询有限考虑使用覆盖索引（避免Innodb表进行索引的二次查找，可以把随机IO变为顺序IO加快查询效率）
7. 尽量避免使用外键（不建议使用外键约束，但一定在表与表之间的关联键上建立索引）（外键可用于保证数据的参照完整性，但建议在业务端实现）

# 数据库字段设计规范
1. 优先选择符合存储需要的最小的数据类型（将字符串转化为数字类型存储）：  
INET_ATON('255.255.255.255')=4294967295  
INET_NTOA(4294967295)='255.255.255.255'  
优先选择符合存储需要的最小的数据类型（对于非负数据采用无符号整型进行存储）  
VARCHAR(N)中的N代表的是字符数，而不是字节数  
使用UTF8存储汉字VARCHAR(255)=765个字节  
2. 避免使用TEXT/BLOB数据类型，VARCHAR一般足够了。如果一定要使用，建议把TEXT列或BLOB列分离到单独的扩展表中  
TEXT或BLOB类型只能使用前缀索引
3. 避免使用ENUM数据类型（修改ENUM值需要使用ALTER语句，且ENUM的ORDER BY操作效率低，需要额外操作）
禁止使用数值作为ENUM的枚举值
4. 尽可能把所有列定义为NOT NULL（索引NULL列需要额外的空间来保存，并且进行比较和计算时要对NULL值做特别的处理）
5. 不要使用字符串存储日期型的数据，而要使用TIMESTAMP(4字节)或DATETIME(8字节)类型存储时间
6. 财务相关的金额类数据，必须使用decimal类型（不会丢失精度，占用空间由定义的宽度决定，可用于存储比bigint更大的整型数据）


# 数据库SQL开发规范
1. 建议使用预编译语句进行数据库操作（只传参数比传递SQL语句更高效，相同语句可以一次解析多次使用以提高处理效率）  
![](http://p1.bqimg.com/567571/6a626c5abba297de.png)  
2. 避免数据类型的隐式转换（会导致索引失效）  
3. 充分利用表上已存在的索引（避免使用双%号的查询条件  
![](http://p1.bpimg.com/567571/73c8fd581c36bb39.png)
4. 程序连接不同的数据库使用不同的账号，禁止跨库查询  
5. 禁止使用SELECT *，必须使用SELECT <字段列表>查询（减少CPU和IO以及网络带宽资源的消耗，避免无法使用覆盖索引，而且可减少表结构变更带来的影响）  
6. 禁止使用不含字段列表的INSERT语句（可减少表结构变更带来的影响）  
![](http://p1.bqimg.com/567571/25b3ec97e8400fcf.png)
7. 禁止使用子查询，可以把子查询优化为join操作  
![](http://p1.bpimg.com/567571/70b8f2f1277d619f.png)
8. 避免使用JOIN关联太多的表  
![](http://p1.bqimg.com/567571/cb6a1a314e822676.png)
9. 减少同数据库的交互次数，尽量一次批量操作  
![](http://p1.bqimg.com/567571/fe3af13093ecbaf7.png)
10. 使用in代替or，但in的值不要超过500个（in操作可以有效地利用索引）  
11. 禁止使用ORDER BY RAND()进行随机排序    
![](http://p1.bqimg.com/567571/a4167590eba66831.png)
12. WHERE从句中禁止对列进行函数转换和计算  
![](http://i1.piimg.com/567571/1d3522a09b61a007.png)
13. 在明显不会有重复值时使用UNION ALL而不是UNION  
![](http://i1.piimg.com/567571/57a01bb6e6ec0ef7.png)
14. 拆分复杂的大SQL为多个小SQL  
![](http://p1.bqimg.com/567571/a4d4cb36431f2260.png)

# 数据库操作行为规范
1. 超100万行的批量写操作，要分批次多次进行操作  
![](http://p1.bpimg.com/567571/3ef6b7d9a1259e61.png)
2. 对于大表使用pt-online-schema-change修改表结构  
![](http://p1.bqimg.com/567571/7c3bbce6a1c21c92.png)
3. 禁止为程序使用的账号赋予super权限  
![](http://i1.piimg.com/567571/71d614333724a226.png)
4. 对于程序连接数据库账号，遵循权限最小原则  
![](http://i1.piimg.com/567571/e9780c30badedcc2.png)