python re模块重要函数变量:
```
1. compile() 根据正则表达式字符串，创建模式的对象。  
2. search() 在字符串中寻找模式。  
3. match() 在字符串开始处匹配模式。  
4. split() 根据模式的匹配项来分割字符串。  
5. findall() 显示出字符串中模式的所有匹配项。  
6. sub(old,new) 方法的功能是，用将所有old的匹配项用new替换掉。  
7. escape() 将字符串中所有特殊正则表达式字符转义。  
```

1. `re.compile`:可以把正则表达式编译成一个正则表达式对象。可以把那些经常使用的正则表达式编译成正则表达式对象，这样可以提高一定的效率。
    ```python
    import re
    text = "JGood is a handsome boy, he is cool, clever, and so on..."
    regex = re.compile(r'\w*oo\w*')
    print regex.findall(text)   #查找所有包含'oo'的单词
    print regex.sub(lambda m: '[' + m.group(0) + ']', text) #将字符串中含有'oo'的单词用[]括起来。
    ```

2. `re.split()`:会根据模式的匹配项来分割字符串，类似于我们字符串的split方法，不过它是用完整的正则表达式来替代了固定的分隔符。
`re.split(r'\s+', text)`将字符串按空格分割成一个单词列表。

3. `　re.findall`:可以获取字符串中所有匹配的字符串。
`re.findall(r'\w*oo\w*', text)`获取字符串中，包含'oo'的所有单词。

4. `re.sub()`用于替换字符串中的匹配项。  
    下面一个例子将字符串中的空格 ' ' 替换成 '-' :  
    ```python
    import re
    text = "JGood is a handsome boy, he is cool, clever, and so on..."
    print re.sub(r'\s+', '-', text) 
    ```
    re.sub的函数原型为：re.sub(pattern, repl, string, count)  
    其中第二个函数是替换后的字符串；本例中为'-'  
    第四个参数指替换个数。默认为0，表示每个匹配项都替换。  
    re.sub还允许使用函数对匹配项的替换进行复杂的处理。  
    如：`re.sub(r'\s', lambda m: '[' + m.group(0) + ']', text, 0)`将字符串中的空格' '替换为'[ ]'。

5. `re.match()`:尝试从字符串的开始匹配一个模式，如：下面的例子匹配第一个单词
    ```python
    import re
    text = "JGood is a handsome boy, he is cool, clever, and so on..."
    m = re.match(r"(\w+)\s", text)
    if m:
    print m.group(0), '\n', m.group(1)
    else:
    print 'not match'
    ```  
    re.match的函数原型为：re.match(pattern, string, flags)
    第一个参数是正则表达式，这里为"(\w+)\s"，如果匹配成功，则返回一个Match，否则返回一个None；
    第二个参数表示要匹配的字符串；
    第三个参数是标致位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

5. `re.search()`:会在字符串内查找模式匹配,只到找到第一个匹配然后返回，若字符串无匹配，则返回None。  
    `re.search()`的函数原型为:`re.search(pattern, string, flags)`.每个参数的含意与re.match一样。
    ```
    import re
    text = "JGood is a handsome boy, he is cool, clever, and so on..."
    m = re.search(r'\shan(ds)ome\s', text)
    if m:
    print m.group(0), m.group(1)
    else:
    print 'not search' 
    ```


re.match与re.search的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。

---

    1. (\b)代表着单词的开头或结尾，也就是单词的分界处
    2. (.)匹配除了换行符以外的任意字符
    3. (*)代表的不是字符，不是位置，而是数量。它指定*前边的内容可连续重复使用任意次以使整个表达式得到匹配  
    4. 为了避免重复，可以这样写：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)
    5. (\s)匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等
    6. (\w)匹配字母或数字或下划线或汉字等

---
    表1.常用的元字符
    代码	说明
    .	匹配除换行符以外的任意字符
    \w	匹配字母或数字或下划线或汉字
    \s	匹配任意的空白符
    \d	匹配数字
    \b	匹配单词的开始或结束
    ^	匹配字符串的开始
    $	匹配字符串的结束
    |   或指明一个非贪婪限定符
    \   将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符  
    ()  标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。  
    [   标记一个中括号表达式的开始  
    {   标记限定符表达式的开始    
---
    表2.常用的限定符
    代码/语法	      说明
    *		     重复零次或更多次
    +		     重复一次或更多次
    ?		     重复零次或一次,或指明一个非贪婪限定符
    {n}		     重复n次
    {n,}		 重复n次或更多次
    {m,n}		 重复m到n次

字符转义：使用\来取消这些字符的特殊意义。

字符类：要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？  
很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。  
我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。  

分枝条件:用|把不同的规则分隔开。

分组：如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)。

    表3.常用的反义代码
    代码/语法	说明
    \W		匹配任意不是字母，数字，下划线，汉字的字符
    \S		匹配任意不是空白符的字符
    \D		匹配任意非数字的字符
    \B		匹配不是单词开头或结束的位置
    [^x]		匹配除了x以外的任意字符
    [^aeiou]	匹配除了aeiou这几个字母以外的任意字符

---

后向引用：用于重复搜索前面某个分组匹配的文本。  
例如，\1代表分组1匹配的文本。
\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。  
你也可以自己指定子表达式的组名。  
要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为Word了。  
要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。

---

    表4.常用分组语法
    分类		代码/语法	说明
    捕获		(exp)		匹配exp,并捕获文本到自动命名的组里
    		(?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
    		(?:exp)		匹配exp,不捕获匹配的文本，也不给此分组分配组号
    零宽断言	(?=exp)		匹配exp前面的位置
    		(?<=exp)	匹配exp后面的位置
    		(?!exp)		匹配后面跟的不是exp的位置
    		(?<!exp)	匹配前面不是exp的位置
    注释		(?#comment)	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

零宽断言：用于查找在某些内容(但并不包括这些内容)之前或之后的东西。
(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。  
(?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。  

负向零宽断言：只是想要确保某个字符没有出现，但并不想去匹配它时。  
零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。  
同理，我们可以用(?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。  

注释:(?#comment)

---

贪婪与懒惰:  
贪婪匹配:匹配尽可能多的字符。  
懒惰匹配:匹配尽可能少的字符。用法：前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。  
`a.*?b`匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。  
为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。  

    表5.懒惰限定符
    代码/语法	说明
    *?	重复任意次，但尽可能少重复
    +?	重复1次或更多次，但尽可能少重复
    ??	重复0次或1次，但尽可能少重复
    {n,m}?	重复n到m次，但尽可能少重复
    {n,}?	重复n次以上，但尽可能少重复

    表6.常用的处理选项
    名称	说明
    IgnoreCase(忽略大小写)	匹配时不区分大小写。
    Multiline(多行模式)	更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
    Singleline(单行模式)	更改.的含义，使它与每一个字符匹配（包括换行符\n）。
    IgnorePatternWhitespace(忽略空白)	忽略表达式中的非转义空白并启用由#标记的注释。
    ExplicitCapture(显式捕获)	仅捕获已被显式命名的组。

-----


    表7.尚未详细讨论的语法
    代码/语法	说明
    \a	报警字符(打印它的效果是电脑嘀一声)
    \b	通常是单词分界位置，但如果在字符类里使用代表退格
    \t	制表符，Tab
    \r	回车
    \v	竖向制表符
    \f	换页符
    \n	换行符
    \e	Escape
    \0nn	ASCII代码中八进制代码为nn的字符
    \xnn	ASCII代码中十六进制代码为nn的字符
    \unnnn	Unicode代码中十六进制代码为nnnn的字符
    \cN	ASCII控制字符。比如\cC代表Ctrl+C
    \A	字符串开头(类似^，但不受处理多行选项的影响)
    \Z	字符串结尾或行尾(不受处理多行选项的影响)
    \z	字符串结尾(类似$，但不受处理多行选项的影响)
    \G	当前搜索的开头
    \p{name}	Unicode中命名为name的字符类，例如\p{IsGreek}
    (?>exp)	贪婪子表达式
    (?<x>-<y>exp)	平衡组
    (?im-nsx:exp)	在子表达式exp中改变处理选项
    (?im-nsx)	为表达式后面的部分改变处理选项
    (?(exp)yes|no)	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
    (?(exp)yes)	同上，只是使用空表达式作为no
    (?(name)yes|no)	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
    (?(name)yes)	同上，只是使用空表达式作为no
